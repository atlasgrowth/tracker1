I'll show you the key analytics implementation files:

Client-side tracking (useAnalytics.ts):
// client/src/hooks/useAnalytics.ts 
import { useEffect, useRef } from 'react';
import { useSiteId } from './useBusinessData';
import type { SessionData, PageView, ClickEvent } from '../types/analytics';
export function useAnalytics() {
  const siteId = useSiteId();
  const sessionRef = useRef<SessionData>({
    siteId: siteId || 'unknown',
    startTime: Date.now(),
    lastActive: Date.now(),
    deviceInfo: {
      browser: navigator.userAgent,
      os: navigator.platform,
      screenSize: {
        width: window.screen.width,
        height: window.screen.height
      }
    },
    pageViews: [],
    clicks: [],
    navigationPath: []
  });
  useEffect(() => {
    if (!siteId) return;
    const pageView: PageView = {
      path: window.location.pathname + window.location.search,
      timestamp: Date.now(),
      timeSpent: 0,
      scrollDepth: 0,
      deviceInfo: sessionRef.current.deviceInfo,
      location: { country: 'Unknown', region: 'Unknown' }
    };
    let maxScroll = 0;
    const scrollHandler = () => {
      const scrollPercent = 
        (window.scrollY / (document.documentElement.scrollHeight - window.innerHeight)) * 100;
      maxScroll = Math.max(maxScroll, scrollPercent);
      pageView.scrollDepth = maxScroll;
    };
    document.addEventListener('scroll', scrollHandler);
    const interval = setInterval(() => {
      pageView.timeSpent = Date.now() - pageView.timestamp;
    }, 1000);
    sessionRef.current.pageViews.push(pageView);
    sessionRef.current.navigationPath.push(pageView.path);
    const clickHandler = (e: MouseEvent) => {
      const target = e.target as HTMLElement;
      const click: ClickEvent = {
        path: window.location.pathname + window.location.search,
        timestamp: Date.now(),
        elementId: target.id || 'unknown',
        elementText: target.innerText || '',
        position: { x: e.clientX, y: e.clientY }
      };
      sessionRef.current.clicks.push(click);
    };
    document.addEventListener('click', clickHandler);
    return () => {
      document.removeEventListener('scroll', scrollHandler);
      document.removeEventListener('click', clickHandler);
      clearInterval(interval);
    };
  }, [siteId]);
  return sessionRef.current;
}
Server-side endpoint (routes.ts):
// server/routes.ts
app.post('/api/analytics', async (req, res) => {
  try {
    const analytics = req.body;
    const fileName = `analytics_${analytics.siteId}_${new Date().toISOString().split('T')[0]}.json`;
    await fs.appendFile(
      path.join(process.cwd(), 'analytics', fileName),
      JSON.stringify(analytics) + '\n'
    );
    res.json({ success: true });
  } catch (error) {
    res.status(500).json({ error: 'Failed to save analytics' });
  }
});
app.get('/api/analytics/:siteId', async (req, res) => {
  try {
    const { siteId } = req.params;
    const data = await processAnalyticsData(siteId);
    res.json(data);
  } catch (error) {
    res.status(500).json({ error: 'Failed to process analytics' });
  }
});
Processing analytics (analytics.ts):
// server/analytics.ts
import fs from 'fs/promises';
import path from 'path';
import { AnalyticsData, SessionData } from '../client/src/types/analytics';
export async function processAnalyticsData(siteId: string): Promise<AnalyticsData> {
  const files = await fs.readdir(path.join(process.cwd(), 'analytics'));
  const relevantFiles = files.filter(f => f.startsWith(`analytics_${siteId}_`));
  
  const sessions: SessionData[] = [];
  for (const file of relevantFiles) {
    const content = await fs.readFile(path.join(process.cwd(), 'analytics', file), 'utf-8');
    const lines = content.trim().split('\n');
    sessions.push(...lines.map(line => JSON.parse(line)));
  }
  return {
    totalVisits: new Set(sessions.map(s => s.startTime)).size,
    averageSessionDuration: sessions.reduce((acc, s) => acc + (s.lastActive - s.startTime), 0) / sessions.length,
    pageViews: sessions.reduce((acc, s) => {
      s.pageViews.forEach(v => {
        acc[v.path] = (acc[v.path] || 0) + 1;
      });
      return acc;
    }, {}),
    averageScrollDepth: sessions.reduce((acc, s) => {
      s.pageViews.forEach(v => {
        acc[v.path] = ((acc[v.path] || 0) + v.scrollDepth) / 2;
      });
      return acc;
    }, {}),
    averageTimeSpent: sessions.reduce((acc, s) => {
      s.pageViews.forEach(v => {
        acc[v.path] = ((acc[v.path] || 0) + v.timeSpent) / 2;
      });
      return acc;
    }, {}),
    popularPaths: Object.entries(sessions.reduce((acc, s) => {
      s.navigationPath.forEach(p => {
        acc[p] = (acc[p] || 0) + 1;
      });
      return acc;
    }, {})).sort(([,a], [,b]) => b - a).map(([path]) => path),
    deviceStats: {
      browsers: sessions.reduce((acc, s) => {
        acc[s.deviceInfo.browser] = (acc[s.deviceInfo.browser] || 0) + 1;
        return acc;
      }, {}),
      screenSizes: sessions.reduce((acc, s) => {
        const size = `${s.deviceInfo.screenSize.width}x${s.deviceInfo.screenSize.height}`;
        acc[size] = (acc[size] || 0) + 1;
        return acc;
      }, {})
    },
    locationStats: {
      countries: sessions.reduce((acc, s) => {
        s.pageViews.forEach(v => {
          acc[v.location.country] = (acc[v.location.country] || 0) + 1;
        });
        return acc;
      }, {}),
      regions: sessions.reduce((acc, s) => {
        s.pageViews.forEach(v => {
          acc[v.location.region] = (acc[v.location.region] || 0) + 1;
        });
        return acc;
      }, {})
    }
  };
}